**Сервис назначения ревьюеров для Pull Request'ов**

Тестовое задание на прохождение Backend-стажировки в Авито

**База данных**

Для хранения данных была разработана база данных PostgreSQL. Она включает в себя сущности:
* `team` - команда разработки
* `user` - участник команды разработки, связан с таблицей `team`
* `pull_request` - Pull Request, связанный с `user`'ом, открывшим его
* `assignment` - связующая таблица между `user` и `pull_request`. В ней происходит назначение ревьюеров на pull request'ы

Просмотреть DDL-схему и ER-диаграмму можно в папке `./database`

**Развёртывание**

Приложение развёртывается на Docker-контейнерах через Docker Compose. В корневой директории проекта с файлом
`docker-compose.yaml` в терминале нужно
ввести команду:

```docker-compose up```

Спустя некоторое время сервис запустится на хосте и порту, указанных в `.env`-файлах. В репозитории в этих файлах
указаны такие значения, чтобы можно было обращаться к сервису с устройства-хоста по адресу `localhost:8080`

Тестирование развёртывания проводилось на `Docker Engine` версии `v27.3.1`

**Если не сработал Docker**

Также можно развернуть приложение через без Docker. Понадобится `PostgreSQL 17` и `Python 3.13`.

В базе данных нужно создать базу данных с таким же названием, как в `.env`-файле и выполнить скрипт по пути
`./database/pr_assignment_ddl.sql`

Затем нужно создать по пути `./service` виртуальное окружение Python:

```python -m venv .venv```

Активировать виртуальное окружение:

```.venv\Scripts\activate``` (для Windows)

И установить необходимые зависимости:

```pip install -r requirements.txt```

После этого можно будет запустить сервис командой:

```python main.py```

**Собственные решения**

О некоторых моментах не было указано в ТЗ или OpenAPI, поэтому я принимал решения самостоятельно:
Из общего можно отметить, что не было указано, что возвращать при ошибке выполнения на сервере. Если какая-то инструкция не смогла выполниться, я
возвращаю
```ErrorResponse: {status: 500, message: "Internal Server Error: <error reason>"}```

Остальные, более точные отступления от ТЗ или блоки кода, логика которых может быть не до конца понятной,
прокомментированы в самом коде

Все запросы тестировались через `Postman v11.34.5`

**Дополнительные задания**

Разработан путь `/statistics/pull_request_reviewers_amount` для получения простой статистики - количества ревьюеров для
pull request'а. Endpoint принимает либо строку с единственным `pull_request_id` и тогда возвращается количество
ревьюеров для указанного pull request'а, либо `null`, что возвращает количество ревьюеров для всех pull request'ов в
базе данных.

Endpoint возвращает результаты в формате:

```
{
    reviewers_amount: {
        <pull_request_id>: <количество назначенных ревьюеров>,
        ...,
        ...
    }
}
```

___
На этом endpoint'е на версии сервиса, развёрнутом в Docker, было проведено нагрузочное тестирование с помощью
`Apache JMeter v5.6.3`. 200 виртуальных пользователей запрашивали количество назначенных ревьюеров для 5 различных
pull request'ов раз в секунду. Количество циклов - 10.

Полученные время и надёжность ответа соответствуют требованиям задания. Результаты тестирования находятся по пути
`./load_test_results`
___
Добавлен endpoint `/user/deactivateMany` для деактивации группы пользователей и переназначения открытых pull request'ов,
в котором они являются ревьюерами

Endpoint принимает на вход список `user_id`, которых нужно отключить (`{users: [user_id1, user_id2...]}`) и возвращает
список результатов работы метода `/pullRequests/reassign`. Общий ответ метода:

```
{
    reassignment_responses: {
        <user_id>: <pull request reassignment response(object)>,
        <user_id>: <pull request reassignment response(object)>,
        ...
    }
}
```
___
Для проверки кода использовался линтер из PyCharm для Python по умолчанию. Он проверяет код на его соответствие
общепринятым нормам стиля написания (PEP8), отлавливает ошибки времени выполнения, которые могут появиться при передаче
неправильного количества аргументов в функцию, опечаток в именах переменных и т.д., определяет неиспользуемые пакеты и
переменные и указывает на возможные ошибки, связанные с аннотациями типов.